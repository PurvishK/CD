//LEXICAL

#include<stdio.h> 
#include<ctype.h> 
#include<stdlib.h> 
#include<string.h> 
void main(){
    
    int i=0,j=0,n; 
    void *p; 
    char ch, b[15],c; 
    printf("Expression terminated by $:"); 
    while((c=getchar())!='$') 
    {
        b[i]=c; 
        i++; 
    }
    n=i-1; 
    printf("Given Expression:"); 
    i=0; 
    while(i<=n) 
    {
        printf("%c",b[i]); 
        i++; 
    }
    printf("\n Symbol Table\n"); 
    printf("Symbol \t type"); 
    while(j<=n) 
    {
        c=b[j]; 
        if(isalpha(toascii(c))) 
        {
            p=malloc(c); 
            printf("\n%c \t identifier\n",c);
        }
        else 
        {
            ch=c; 
            if(ch=='+'||ch=='-'||ch=='*'||ch=='=') 
            {
                p=malloc(ch); 
                printf("\n %c \t operator\n",ch); 
            }
        }
    j++; 
    }
}

//algo:
 Step1: Start the program.
 Step2: Declare all the variables and file pointers.
 Step3: Display the input program.
 Step4: Separate the operators of the input program and display it.
 Step5: Separate the identifiers of the input program.
 Step6: Print all the tokens.


//LEXICAL Alternative ////////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <string>
#include<algorithm>
#include <stdlib.h>
#include <string.h>
#include<bits/stdc++.h>

using namespace std;

void printWords(string str)
{
    string word;
 
    stringstream iss(str);

    while (iss >> word)
        cout << word << endl;
}
int main() {
  string x;
  getline (cin, x);
  
  replace(x.begin(), x.end(), ',', ' ');
  replace(x.begin(), x.end(), ';', ' ');
  printWords(x);
  return 0;
}


//algorithm:
//step 1. : Get the input from the user
//step 2. : Replace the separators (i.e. , and ; )
//step 3. : Create a function such that it separates words in the string.
//step 4. : Print the tokens in new line till all the words in the string are not processed


//SYMBOL TABLE

#include<stdio.h> 
#include<ctype.h> 
#include<stdlib.h> 
#include<string.h> 
void main(){
    
    int i=0,j=0,n; 
    void *p; 
    char ch, b[15],c; 
    printf("Expression terminated by $:"); 
    while((c=getchar())!='$') 
    {
        b[i]=c; 
        i++; 
    }
    n=i-1; 
    printf("Given Expression:"); 
    i=0; 
    while(i<=n) 
    {
        printf("%c",b[i]); 
        i++; 
    }
    printf("\n Symbol Table\n"); 
    printf("Symbol \t addr \t type"); 
    while(j<=n) 
    {
        c=b[j]; 
        if(isalpha(toascii(c))) 
        {
            p=malloc(c); 
            printf("\n%c \t %d \t identifier\n",c,p);
        }
        else 
        {
            ch=c; 
            if(ch=='+'||ch=='-'||ch=='*'||ch=='=') 
            {
                p=malloc(ch); 
                printf("\n %c \t %d \t operator\n",ch,p); 
            }
        }
    j++; 
    }
}

//algo:

 Step1: Start the program.
 Step2: Declare all the variables and file pointers.
 Step3: Display the input program.
 Step4: Separate the operators of the input program and display it.
 Step5: Separate the identifiers of the input program.
 Step6: Store the addresses with repect to their tokens
 Step7: Print the symbol table


//RE to NFA

#include<stdio.h>
#include<string.h>
int main()
{
	char reg[20];
	int q[20][3],i,j,len,a,b;
	for(a=0;a<20;a++)
	{
		for(b=0;b<3;b++)
		{
			q[a][b]=0;
		}
	}
	scanf("%s",reg);
	len=strlen(reg);
	i=0;
j=1;
	while(i<len)
	{
		if(reg[i]=='a'&&reg[i+1]!='|'&&reg[i+1]!='*')
		{
			q[j][0]=j+1;
			j++;
		}
		if(reg[i]=='b'&&reg[i+1]!='|'&&reg[i+1]!='*')
		{
			q[j][1]=j+1;
			j++;
		}
		if(reg[i]=='e'&&reg[i+1]!='|'&&reg[i+1]!='*')
		{
			q[j][2]=j+1;
			j++;
		}
		if(reg[i]=='a'&&reg[i+1]=='|'&&reg[i+2]=='b')
		{
			q[j][2]=((j+1)*10)+(j+3);
			j++;
			q[j][0]=j+1;
			j++;
			q[j][2]=j+3;
			j++;
			q[j][1]=j+1;
			j++;
			q[j][2]=j+1;
			j++;
			i=i+2;
		}
		if(reg[i]=='b'&&reg[i+1]=='|'&&reg[i+2]=='a')
		{
			q[j][2]=((j+1)*10)+(j+3);
			j++;
			q[j][1]=j+1;
			j++;
			q[j][2]=j+3;
			j++;
			q[j][0]=j+1;
			j++;
			q[j][2]=j+1;
			j++;
			i=i+2;
		}
		if(reg[i]=='a'&&reg[i+1]=='*')
		{
			q[j][2]=((j+1)*10)+(j+3);
			j++;
			q[j][0]=j+1;
			j++;
			q[j][2]=((j+1)*10)+(j-1);
			j++;
		}
		if(reg[i]=='b'&&reg[i+1]=='*')
		{
			q[j][2]=((j+1)*10)+(j+3);
			j++;
			q[j][1]=j+1;
			j++;
			q[j][2]=((j+1)*10)+(j-1);
			j++;
		}
		if(reg[i]==')'&&reg[i+1]=='*')
		{
			q[0][2]=((j+1)*10)+1;
			q[j][2]=((j+1)*10)+1;
			j++;
		}
		i++;
	}
	printf("Transition function \n");
	for(i=0;i<=j;i++)
	{
		if(q[i][0]!=0)
			printf("\n q[%d,a]-->%d",i,q[i][0]);
		if(q[i][1]!=0)
			printf("\n q[%d,b]-->%d",i,q[i][1]);
		if(q[i][2]!=0)
		{
			if(q[i][2]<10)
				printf("\n q[%d,e]-->%d",i,q[i][2]);
			else
				printf("\n q[%d,e]-->%d & %d",i,q[i][2]/10,q[i][2]%10);
		}
	}
	return 0;
}

//algo:

1. Start the program
2. Take the RE from the user
3. Separate the input into different cases
4. Assign the nodes according to the cases
5. Print all the transitions


//NFA to DFA

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define MAX_LEN 100
char NFA_FILE[MAX_LEN];
char buffer[MAX_LEN];
int zz = 0;
// Structure to store DFA states and their
// status (i.e new entry or already present)
struct DFA
{
	char *states;
	int count;
}

dfa;
int last_index = 0;
FILE * fp;
int symbols;
void reset(int ar[], int size)
{
	int i;
	for (i = 0; i < size; i++)
	{
		ar[i] = 0;
	}
}

void check(int ar[], char S[])
{
	int i, j;
	int len = strlen(S);
	for (i = 0; i < len; i++)
	{
		j = ((int)(S[i]) - 65);
		ar[j]++;
	}
}

void state(int ar[], int size, char S[])
{
	int j, k = 0;
	for (j = 0; j < size; j++)
	{
		if (ar[j] != 0)
			S[k++] = (char)(65 + j);
	}

	S[k] = '\0';
}

int closure(int ar[], int size)
{
	int i;
	for (i = 0; i < size; i++)
	{
		if (ar[i] == 1)
			return i;
	}

	return (100);
}

int indexing(struct DFA *dfa)
{
	int i;
	for (i = 0; i < last_index; i++)
	{
		if (dfa[i].count == 0)
			return 1;
	}

	return -1;
}

void Display_closure(int states, int closure_ar[],
	char *closure_table[],
	char *NFA_TABLE[][symbols + 1],
	char *DFA_TABLE[][symbols])
{
	int i;
	for (i = 0; i < states; i++)
	{
		reset(closure_ar, states);
		closure_ar[i] = 2;
		if (strcmp(&NFA_TABLE[i][symbols], "-") != 0)
		{
			strcpy(buffer, &NFA_TABLE[i][symbols]);
			check(closure_ar, buffer);
			int z = closure(closure_ar, states);
			while (z != 100)
			{
				if (strcmp(&NFA_TABLE[z][symbols], "-") != 0)
				{
					strcpy(buffer, &NFA_TABLE[z][symbols]);
					check(closure_ar, buffer);
				}

				closure_ar[z]++;
				z = closure(closure_ar, states);
			}
		}

		printf("\n e-Closure (%c) :\t", (char)(65 + i));
		bzero((void*) buffer, MAX_LEN);
		state(closure_ar, states, buffer);
		strcpy(&closure_table[i], buffer);
		printf("%s\n", &closure_table[i]);
	}
}

int new_states(struct DFA *dfa, char S[])
{
	int i;
	for (i = 0; i < last_index; i++)
	{
		if (strcmp(&dfa[i].states, S) == 0)
			return 0;
	}

	strcpy(&dfa[last_index++].states, S);
	dfa[last_index - 1].count = 0;
	return 1;
}

void trans(char S[], int M, char *clsr_t[], int st,
	char *NFT[][symbols + 1], char TB[])
{
	int len = strlen(S);
	int i, j, k, g;
	int arr[st];
	int sz;
	reset(arr, st);
	char temp[MAX_LEN], temp2[MAX_LEN];
	char *buff;
	for (i = 0; i < len; i++)
	{
		j = ((int)(S[i] - 65));
		strcpy(temp, &NFT[j][M]);
		if (strcmp(temp, "-") != 0)
		{
			sz = strlen(temp);
			g = 0;
			while (g < sz)
			{
				k = ((int)(temp[g] - 65));
				strcpy(temp2, &clsr_t[k]);
				check(arr, temp2);
				g++;
			}
		}
	}

	bzero((void*) temp, MAX_LEN);
	state(arr, st, temp);
	if (temp[0] != '\0')
	{
		strcpy(TB, temp);
	}
	else
		strcpy(TB, "-");
}

void Display_DFA(int last_index, struct DFA *dfa_states,
	char *DFA_TABLE[][symbols])
{
	int i, j;
	printf("\n\n********************************************************\n\n");
	printf("\t\t DFA TRANSITION STATE TABLE \t\t \n\n");
	printf("\n STATES OF DFA :\t\t");
	for (i = 1; i < last_index; i++)
		printf("%s, ", &dfa_states[i].states);
	printf("\n");
	printf("\n GIVEN SYMBOLS FOR DFA: \t");
	for (i = 0; i < symbols; i++)
		printf("%d, ", i);
	printf("\n\n");
	printf("STATES\t");
	for (i = 0; i < symbols; i++)
		printf("|%d\t", i);
	printf("\n");
	printf("--------+-----------------------\n");
	for (i = 0; i < zz; i++)
	{
		printf("%s\t", &dfa_states[i + 1].states);
		for (j = 0; j < symbols; j++)
		{
			printf("|%s \t", &DFA_TABLE[i][j]);
		}

		printf("\n");
	}
}

int main()
{
	int i, j, states;
	char T_buf[MAX_LEN];
	struct DFA *dfa_states = malloc(MAX_LEN *(sizeof(dfa)));
	states = 3, symbols = 2;
	printf("\n STATES OF NFA :\t\t");
	for (i = 0; i < states; i++)
		printf("%c, ", (char)(65 + i));
	printf("\n");
	printf("\n GIVEN SYMBOLS FOR NFA: \t");
	for (i = 0; i < symbols; i++)
		printf("%d, ", i);
	printf("eps");
	printf("\n\n");
	char *NFA_TABLE[states][symbols + 1];
	char *DFA_TABLE[MAX_LEN][symbols];
	strcpy(&NFA_TABLE[0][0], "BC");
	strcpy(&NFA_TABLE[0][1], "A");
	strcpy(&NFA_TABLE[0][2], "B");
	strcpy(&NFA_TABLE[1][0], "-");
	strcpy(&NFA_TABLE[1][1], "B");
	strcpy(&NFA_TABLE[1][2], "C");
	strcpy(&NFA_TABLE[2][0], "C");
	strcpy(&NFA_TABLE[2][1], "C");
	strcpy(&NFA_TABLE[2][2], "-");
	printf("\n NFA STATE TRANSITION TABLE \n\n\n");
	printf("STATES\t");
	for (i = 0; i < symbols; i++)
		printf("|%d\t", i);
	printf("eps\n");
	printf("--------+------------------------------------\n");
	for (i = 0; i < states; i++)
	{
		printf("%c\t", (char)(65 + i));
		for (j = 0; j <= symbols; j++)
		{
			printf("|%s \t", &NFA_TABLE[i][j]);
		}

		printf("\n");
	}

	int closure_ar[states];
	char *closure_table[states];
	Display_closure(states, closure_ar, closure_table, NFA_TABLE, DFA_TABLE);
	strcpy(&dfa_states[last_index++].states, "-");
	dfa_states[last_index - 1].count = 1;
	bzero((void*) buffer, MAX_LEN);
	strcpy(buffer, &closure_table[0]);
	strcpy(&dfa_states[last_index++].states, buffer);
	int Sm = 1, ind = 1;
	int start_index = 1;
	while (ind != -1)
	{
		dfa_states[start_index].count = 1;
		Sm = 0;
		for (i = 0; i < symbols; i++)
		{
			trans(buffer, i, closure_table, states, NFA_TABLE, T_buf);
			strcpy(&DFA_TABLE[zz][i], T_buf);
			Sm = Sm + new_states(dfa_states, T_buf);
		}

		ind = indexing(dfa_states);
		if (ind != -1)
			strcpy(buffer, &dfa_states[++start_index].states);
		zz++;
	}

	Display_DFA(last_index, dfa_states, DFA_TABLE);
	return 0;
}

//algo:

Algorithm:
1.	Take ∈ closure for the beginning state of NFA as beginning state of DFA.
2.	Find the states that can be traversed from the present for each input symbol
(union of transition value and their closures for each states of NFA present in current state of DFA).
3.	If any new state is found take it as current state and repeat step 2.
4.	Do repeat Step 2 and Step 3 until no new state present in DFA transition table.
5.	Mark the states of DFA which contains final state of NFA as final states of DFA.




//LEFT RECURSION:

#include<iostream>
#include<string>
using namespace std;
int main()
{  string ip,op1,op2,temp;
    int sizes[10] = {};
    char c;
    int n,j,l;
    cout<<"Enter the Parent Non-Terminal : ";
    cin>>c;
    ip.push_back(c);
    op1 += ip + "\'->";
    ip += "->";
    op2+=ip;
    cout<<"Enter the number of productions : ";
    cin>>n;
    for(int i=0;i<n;i++)
    {   cout<<"Enter Production "<<i+1<<" : ";
        cin>>temp;
        sizes[i] = temp.size();
        ip+=temp;
        if(i!=n-1)
            ip += "|";
    }
    cout<<"Production Rule : "<<ip<<endl;
    for(int i=0,k=3;i<n;i++)
    {
        if(ip[0] == ip[k])
        {
            cout<<"Production "<<i+1<<" has left recursion."<<endl;
            if(ip[k] != 'e')
            {
                for(l=k+1;l<k+sizes[i];l++)
                    op1.push_back(ip[l]);
                k=l+1;
                op1.push_back(ip[0]);
                op1 += "\'|";
            }
        }
        else
        {
            cout<<"Production "<<i+1<<" does not have left recursion."<<endl;
            if(ip[k] != 'e')
            {
                for(j=k;j<k+sizes[i];j++)
                    op2.push_back(ip[j]);
                k=j+1;
                op2.push_back(ip[0]);
                op2 += "\'|";
            }
            else
            {
                op2.push_back(ip[0]);
                op2 += "\'";
            }}}
    op1 += "e";
    cout<<op2<<endl;
    cout<<op1<<endl;
    return 0;}

//algo:

1.	Start the program.
2.	Initialize the arrays for taking input from the user.
3.	Prompt the user to input the no. of non-terminals having left recursion and no. of productions for these non-terminals.
4.	Prompt the user to input the production for non-terminals.
5.	Eliminate left recursion using the following rules:-
A->Aα1| Aα2 | . . . . . |Aαm
A->β1| β2| . . . . .| βn
Then replace it by
A-> βi A’ i=1,2,3,…..m
A’-> αj A’ j=1,2,3,…..n
A’-> Ɛ
6.	After eliminating the left recursion by applying these rules, display the productions without left recursion.
7.	Stop.




//LEFT FACTORING


  #include<stdio.h>  
  #include<string.h>  
  int main()  
  {  
       char gram[20],part1[20],part2[20],modifiedGram[20],newGram[20],tempGram[20];  
       int i,j=0,k=0,l=0,pos;  
       printf("Enter Production : A->");  
       gets(gram);  
       for(i=0;gram[i]!='|';i++,j++)  
            part1[j]=gram[i];  
       part1[j]='\0';  
       for(j=++i,i=0;gram[j]!='\0';j++,i++)  
            part2[i]=gram[j];  
       part2[i]='\0';  
       for(i=0;i<strlen(part1)||i<strlen(part2);i++)  
       {  
            if(part1[i]==part2[i])  
            {  
                 modifiedGram[k]=part1[i];  
                 k++;  
                 pos=i+1;  
            }  
       }  
       for(i=pos,j=0;part1[i]!='\0';i++,j++){  
            newGram[j]=part1[i];  
       }  
       newGram[j++]='|';  
       for(i=pos;part2[i]!='\0';i++,j++){  
            newGram[j]=part2[i];  
       }  
       modifiedGram[k]='X';  
       modifiedGram[++k]='\0';  
       newGram[j]='\0';  
       printf("\n A->A'");  
       printf("\n X->%s\n",newGram);  
}

//algo:

1.	Start
2.	Ask the user to enter the set of productions
3.	Check for common symbols in the given set of productions by comparing with:
A->aB1|aB2
4.	If found, replace the particular productions with:
A->aA’
A’->B1 | B2
5.	Display the output
6.	Exit.



//FIRST AND FOLLOW

#include <stdio.h>
#include <conio.h>
#include <string.h>
int main()
{
	char fin[10][20], st[10][20], ft[20][20], fol[20][20];
	int a = 0, e, i, t, b, c, n, k, l = 0, j, s, m, p;
	printf("enter the no. of productions\n");
	scanf("%d", &n);
	printf("enter the productions in a grammar\n");
	for (i = 0; i < n; i++)
		scanf("%s", st[i]);
	for (i = 0; i < n; i++)
		fol[i][0] = '\0';
	for (s = 0; s < n; s++)
	{
		for (i = 0; i < n; i++)
		{
			j = 3;
			l = 0;
			a = 0;
			l1: if (!((st[i][j] > 64) && (st[i][j] < 91)))
			{
				for (m = 0; m < l; m++)
				{
					if (ft[i][m] == st[i][j])
						goto s1;
				}

				ft[i][l] = st[i][j];
				l = l + 1;
				s1: j = j + 1;
			}
			else
			{
				if (s > 0)
				{
					while (st[i][j] != st[a][0])
					{
						a++;
					}

					b = 0;
					while (ft[a][b] != '\0')
					{
						for (m = 0; m < l; m++)
						{
							if (ft[i][m] == ft[a][b])
								goto s2;
						}

						ft[i][l] = ft[a][b];
						l = l + 1;
						s2: b = b + 1;
					}
				}
			}

			while (st[i][j] != '\0')
			{
				if (st[i][j] == '|')
				{
					j = j + 1;
					goto l1;
				}

				j = j + 1;
			}

			ft[i][l] = '\0';
		}
	}

	printf("first\n");
	for (i = 0; i < n; i++)
		printf("first[%c]=%s\n", st[i][0], ft[i]);
	fol[0][0] = '$';
	for (i = 0; i < n; i++)
	{
		k = 0;
		j = 3;
		if (i == 0)
			l = 1;
		else
			l = 0;
		k1: while ((st[i][0] != st[k][j]) && (k < n))
		{
			if (st[k][j] == '\0')
			{
				k++;
				j = 2;
			}

			j++;
		}

		j = j + 1;
		if (st[i][0] == st[k][j - 1])
		{
			if ((st[k][j] != '|') && (st[k][j] != '\0'))
			{
				a = 0;
				if (!((st[k][j] > 64) && (st[k][j] < 91)))
				{
					for (m = 0; m < l; m++)
					{
						if (fol[i][m] == st[k][j])
							goto q3;
					}

					fol[i][l] = st[k][j];
					l++;
					q3: p++;
				}
				else
				{
					while (st[k][j] != st[a][0])
					{
						a++;
					}

					p = 0;
					while (ft[a][p] != '\0')
					{
						if (ft[a][p] != 'e')
						{
							for (m = 0; m < l; m++)
							{
								if (fol[i][m] == ft[a][p])
									goto q2;
							}

							fol[i][l] = ft[a][p];
							l = l + 1;
						}
						else
							e = 1;
						q2: p++;
					}

					if (e == 1)
					{
						e = 0;
						goto a1;
					}
				}
			}
			else
			{
				a1: c = 0;
				a = 0;
				while (st[k][0] != st[a][0])
				{
					a++;
				}

				while ((fol[a][c] != '\0') && (st[a][0] != st[i][0]))
				{
					for (m = 0; m < l; m++)
					{
						if (fol[i][m] == fol[a][c])
							goto q1;
					}

					fol[i][l] = fol[a][c];
					l++;
					q1: c++;
				}
			}

			goto k1;
		}

		fol[i][l] = '\0';
	}

	printf("follow\n");
	for (i = 0; i < n; i++)
		printf("follow[%c]=%s\n", st[i][0], fol[i]);
	printf("\n");
	s = 0;
	for (i = 0; i < n; i++)
	{
		j = 3;
		while (st[i][j] != '\0')
		{
			if ((st[i][j - 1] == '|') || (j == 3))
			{
				for (p = 0; p <= 2; p++)
				{
					fin[s][p] = st[i][p];
				}

				t = j;
				for (p = 3;
					((st[i][j] != '|') && (st[i][j] != '\0')); p++)
				{
					fin[s][p] = st[i][j];
					j++;
				}

				fin[s][p] = '\0';
				if (st[i][t] == 'e')
				{
					b = 0;
					a = 0;
					while (st[a][0] != st[i][0])
					{
						a++;
					}

					while (fol[a][b] != '\0')
					{
						printf("M[%c,%c]=%s\n", st[i][0], fol[a][b], fin[s]);
						b++;
					}
				}
				else if (!((st[i][t] > 64) && (st[i][t] < 91)))
					printf("M[%c,%c]=%s\n", st[i][0], st[i][t], fin[s]);
				else
				{
					b = 0;
					a = 0;
					while (st[a][0] != st[i][3])
					{
						a++;
					}

					while (ft[a][b] != '\0')
					{
						printf("M[%c,%c]=%s\n", st[i][0], ft[a][b], fin[s]);
						b++;
					}
				}

				s++;
			}

			if (st[i][j] == '|')
				j++;
		}
	}

	return 0;
}

//Algo:

1.	Start.
2.	Get the input production rules of the grammar.
3.	To compute FIRST(X) for all grammar symbols X, apply the following rules until no more terminals or can be added to any FIRST set.
●	If X is a terminal, then FIRST(X) = {X}.
●	If X → ε is a production, then add ε to FIRST(X).
●	If X is a non-terminal and X → Y1 Y2 ··· Yk is a production, then add FIRST(Y1) to FIRST(X).
If Y1 derives ε, then add FIRST(Y2) to FIRST(X).
4.	To compute FOLLOW(X) for all grammar symbols X, apply the following rules until no more terminals or can be added to any FOLLOW set.
●	For the FOLLOW(start symbol) place $, where $ is the input end marker.
●	If there is a production A → αBβ, then everything in FIRST(β) except ε is in FOLLOW(B).
●	If there is a production A → αB, or a production A → αBβ where
●	FIRST(β) contains ε, then everything in FOLLOW(A) is in FOLLOW(B).
5.	Stop.




//LL1


#include <stdio.h>
#include <conio.h>
#include <string.h>

int main()
{
	char fin[10][20], st[10][20], ft[20][20], fol[20][20];
	int a = 0, e, i, t, b, c, n, k, l = 0, j, s, m, p;
	printf("enter the no. of productions\n");
	scanf("%d", &n);
	printf("enter the productions in a grammar\n");
	for (i = 0; i < n; i++)
		scanf("%s", st[i]);
	for (i = 0; i < n; i++)
		fol[i][0] = '\0';
	for (s = 0; s < n; s++)
	{
		for (i = 0; i < n; i++)
		{
			j = 3;
			l = 0;
			a = 0;
			l1: if (!((st[i][j] > 64) && (st[i][j] < 91)))
			{
				for (m = 0; m < l; m++)
				{
					if (ft[i][m] == st[i][j])
						goto s1;
				}

				ft[i][l] = st[i][j];
				l = l + 1;
				s1: j = j + 1;
			}
			else
			{
				if (s > 0)
				{
					while (st[i][j] != st[a][0])
					{
						a++;
					}

					b = 0;
					while (ft[a][b] != '\0')
					{
						for (m = 0; m < l; m++)
						{
							if (ft[i][m] == ft[a][b])
								goto s2;
						}

						ft[i][l] = ft[a][b];
						l = l + 1;
						s2: b = b + 1;
					}
				}
			}

			while (st[i][j] != '\0')
			{
				if (st[i][j] == '|')
				{
					j = j + 1;
					goto l1;
				}

				j = j + 1;
			}

			ft[i][l] = '\0';
		}
	}

	printf("first\n");
	for (i = 0; i < n; i++)
		printf("first[%c]=%s\n", st[i][0], ft[i]);
	fol[0][0] = '$';
	for (i = 0; i < n; i++)
	{
		k = 0;
		j = 3;
		if (i == 0)
			l = 1;
		else
			l = 0;
		k1: while ((st[i][0] != st[k][j]) && (k < n))
		{
			if (st[k][j] == '\0')
			{
				k++;
				j = 2;
			}

			j++;
		}

		j = j + 1;
		if (st[i][0] == st[k][j - 1])
		{
			if ((st[k][j] != '|') && (st[k][j] != '\0'))
			{
				a = 0;
				if (!((st[k][j] > 64) && (st[k][j] < 91)))
				{
					for (m = 0; m < l; m++)
					{
						if (fol[i][m] == st[k][j])
							goto q3;
					}

					fol[i][l] = st[k][j];
					l++;
					q3: p++;
				}
				else
				{
					while (st[k][j] != st[a][0])
					{
						a++;
					}

					p = 0;
					while (ft[a][p] != '\0')
					{
						if (ft[a][p] != 'e')
						{
							for (m = 0; m < l; m++)
							{
								if (fol[i][m] == ft[a][p])
									goto q2;
							}

							fol[i][l] = ft[a][p];
							l = l + 1;
						}
						else
							e = 1;
						q2: p++;
					}

					if (e == 1)
					{
						e = 0;
						goto a1;
					}
				}
			}
			else
			{
				a1: c = 0;
				a = 0;
				while (st[k][0] != st[a][0])
				{
					a++;
				}

				while ((fol[a][c] != '\0') && (st[a][0] != st[i][0]))
				{
					for (m = 0; m < l; m++)
					{
						if (fol[i][m] == fol[a][c])
							goto q1;
					}

					fol[i][l] = fol[a][c];
					l++;
					q1: c++;
				}
			}

			goto k1;
		}

		fol[i][l] = '\0';
	}

	printf("follow\n");
	for (i = 0; i < n; i++)
		printf("follow[%c]=%s\n", st[i][0], fol[i]);
	printf("\n");
	s = 0;
	for (i = 0; i < n; i++)
	{
		j = 3;
		while (st[i][j] != '\0')
		{
			if ((st[i][j - 1] == '|') || (j == 3))
			{
				for (p = 0; p <= 2; p++)
				{
					fin[s][p] = st[i][p];
				}

				t = j;
				for (p = 3;
					((st[i][j] != '|') && (st[i][j] != '\0')); p++)
				{
					fin[s][p] = st[i][j];
					j++;
				}

				fin[s][p] = '\0';
				if (st[i][t] == 'e')
				{
					b = 0;
					a = 0;
					while (st[a][0] != st[i][0])
					{
						a++;
					}

					while (fol[a][b] != '\0')
					{
						printf("M[%c,%c]=%s\n", st[i][0], fol[a][b], fin[s]);
						b++;
					}
				}
				else if (!((st[i][t] > 64) && (st[i][t] < 91)))
					printf("M[%c,%c]=%s\n", st[i][0], st[i][t], fin[s]);
				else
				{
					b = 0;
					a = 0;
					while (st[a][0] != st[i][3])
					{
						a++;
					}

					while (ft[a][b] != '\0')
					{
						printf("M[%c,%c]=%s\n", st[i][0], ft[a][b], fin[s]);
						b++;
					}
				}

				s++;
			}

			if (st[i][j] == '|')
				j++;
		}
	}

	return 0;
}


//algo:

1.	Start.
2.	Get the input production rules of the grammar.
3.	For each production A -> x of the grammar, do the following :
●	For each terminal a in FIRST(x), add A -> x to M[A, a].
●	If epsilon is in FIRST(x), then for each terminal b in FOLLOW(A), add A -> x to M[A, b].
●	If epsilon is in FIRST(x) and $ is in FOLLOW(A), add A -> x to M[A, $] as well.
●	If, after performing the above, there is no production at all in M[A, a], then set M[A, a] to error (which we normally represent by an empty entry in the table).
4.	Stop.
